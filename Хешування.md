
   - **Хеш-функція**: Це функція, яка приймає вхідні дані (текстовий рядок, файл тощо) і генерує фіксований рядок фіксованої довжини, відомий як "хеш-значення" або просто "хеш". Хеш-функція повинна бути швидкою та ефективною, і навіть невелика зміна вхідних даних повинна призводити до великої зміни в хеш-значенні.

   - **Використання хешування**: Хешування використовується для перетворення великої кількості даних у фіксовану довжину, що є корисним для швидкого пошуку та порівняння даних. Важливе використання хешування - збереження паролів користувачів у безпечному вигляді, коли ви зберігаєте лише хеш пароля, а не сам пароль.

   - **Властивості хешування**: Дві однакові вхідні послідовності повинні давати однаковий хеш. Але навіть маленька зміна вхідних даних повинна призводити до зміни хеш-значення. Хеш-функція повинна бути важкою для зворотного обчислення (тобто важко відновити вхідні дані з хеш-значення).

## Сіль (Salt)

   - **Сіль** - це випадкова послідовність байтів, яка додається до вхідних даних перед хешуванням. Це додає додатковий рівень безпеки до процесу збереження паролів.

   - **Значення солі**: Сіль додається до вхідних даних перед хешуванням, і кожен користувач може мати свою власну унікальну сіль. Це означає, що навіть якщо два користувача мають однаковий пароль, їхні хеш-значення будуть різними через використання різних солей. Це ускладнює атаки на бази даних з хешами паролів.

   - **Застосування солі**: Сіль використовується для збереження паролів користувачів в безпечному вигляді. При перевірці введеного пароля на відповідність, сіль також використовується для генерації хеш-значення та порівняння збереженого хеша з введеним. Це ускладнює атаки на бази даних та підвищує безпеку паролів.

Важливою рекомендацією є використання солі разом з хешуванням паролів для збереження їх в безпечному вигляді. Також, важливо використовувати сильні хеш-функції, які важко обчислити зворотньо.

## приклад коду на Python

```python
import hashlib
import os

# Функція для генерації солі
def generate_salt():
    return os.urandom(16)  # 16 байтів солі (128 біт)

# Функція для хешування паролю з використанням солі
def hash_password(password, salt=None):
    if salt is None:
        salt = generate_salt()
    else:
        salt = bytes.fromhex(salt)  
    
    salted_password = password.encode() + salt
    
    hashed_password = hashlib.sha256(salted_password).hexdigest()
    
    return hashed_password, salt.hex()

def verify_password(stored_hashed_password, stored_salt, provided_password):
    # За допомогою збереженої солі та введеного паролю обчислюємо хеш
    calculated_hashed_password, _ = hash_password(provided_password, stored_salt)
    
    # Порівнюємо обчислений хеш зі збереженим хешем
    return calculated_hashed_password == stored_hashed_password

# Реєстрація користувача
username = "example_user"
password = "secure_password"

# Генеруємо сіль та хеш паролю
hashed_password, salt = hash_password(password)

# Зберігаємо хеш паролю та сіль у базі даних або файлі
print(f"Збережений хеш паролю: {hashed_password}")
print(f"Збережена сіль: {salt}")

# Перевірка паролю при авторизації
provided_password = "secure_password"
if verify_password(hashed_password, salt, provided_password):
	print("Пароль вірний. Доступ наданий.")
else:
	print("Пароль невірний. Доступ заборонений.")
```

У цьому прикладі ми використовуємо хеш-функцію SHA-256 для створення хешу паролю разом зі соллю. Сіль генерується випадково та об'єднується з паролем перед хешуванням. При авторизації ми можемо перевірити введений пароль зі збереженим хешем та сіллю, щоб перевірити відповідність.